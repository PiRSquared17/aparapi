#summary How to make use of local memory in a Kernel

=How to make use of new local memory feature=

By default all primitive arrays accessed by an Aparapi Kernel is considered global. If we look at the generated code {{{using -Dcom.amd.aparapi.enableShowGeneratedOpenCL=true}}} we will see that primitive arrays (such as {{{int buf[]}}}) are mapped to {{{__global}}} pointers (such as {{{__global int *buf}}}) in OpenCL.

Although this makes Aparapi easy to use (especially to Java developers who are unfamiliar to tiered memory hierarchies), it does limit the ability of the 'power developer' wanting to extract more performance from Aparapi on the GPU.

This [http://www.amd.com/us/products/technologies/stream-technology/opencl/pages/opencl-intro.aspx?cmpid=cp_article_2_2010 page] from AMD's website shows the different types of memory that OpenCL programmers can exploit.

http://www.amd.com/PublishingImages/Public/Graphic_Illustrations/375WJPEG/47039A_OpenCLMemoryModel_375W.jpg 

Global memory buffers in Aparapi (primitive Java arrays) are stored in host memory and are copied to Global memory (the RAM of the GPU card).  

Local memory is 'closer' to the compute devices and not copied from the host memory, it is just allocated for use on the device. The use of local memory on OpenCL can lead to much more performant code as the cost of fetching from local memory is much lower.

Local memory is shared by all work item's (kernel instances) executing in the same group.  This is why the use of local memory was deferred until we had a satisfactory mechanism for specifying a required group size. 
==How to define a primitive array as "local"== 
We have two ways define a local buffer. Either we can decorate the variable name with a {{{_$local$}}} suffix (yes it is a valid identifier n Java).

{{{
final int[] buffer = new int[1024]; // this is global accessable to all work items.
final int[] buffer_$local$ = new int[1024]; // this is a local buffer 1024 int's shared across all work item's in a group

Kernel k = new Kernel(){
    public void run(){
         // access buffer
         // access buffer_$local$
         localBarrier(); // allows all writes to buffer_$local$ to be synchronized across all work items in this group
         // ....
    }
}
}}}

Alternatively (if defining inside the derived Kernel class - cannot be
used via anonymous inner class pattern above!) we can can use the {{{@Local}}} annotation.

{{{
final int[] buffer = new int[1024]; // this is global accessable to all work items.

Kernel k = new Kernel(){
    @Local int[] localBuffer = new int[1024]; // this is a local
buffer 1024 int's shared across all work item's in a group
    public void run(){
         // access buffer
         // access localBuffer
         localBarrier(); // allows all writes to localBuffer to be synchronized across all work items in this group
         // ....
    }
}
}}}

I added a version of {{{NBody}}} example which uses local memory, the source can be found here. 

http://code.google.com/p/aparapi/source/browse/trunk/examples/nbody/src/com/amd/aparapi/examples/nbody/Local.java