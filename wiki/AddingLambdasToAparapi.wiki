#summary Adding Lambdas to Aparapi

Eric Caspole and I have been trying to enable Aparapi using the existing Java 8 lambdas [http://openjdk.java.net/projects/lambda/ here] preview. 

We have created a branch called !SumatraExperiments to track our proposed changes. [http://code.google.com/p/aparapi/source/browse/#svn%2Fbranches%2FSumatraExperiments Here] is the link to the source tree we are playing with.

You will need to get the latest binary build of lambdas to make the code in this branch work. The lambda preview can be found [http://jdk8.java.net/lambda/ here].

Then set JAVA_HOME to your Java8 Lambda enabled compiler and build Aparapi. 

So from the root of {{{SumatraExperiments}}} just use

{{{
$ ant 
}}}


We are slowly walking through some of the Aparapi demos and converting them.  At present NBody and Mandel have been converted. 

----

So instead of deriving from a base Kernel class, we now allow the user to express their code as a lambda

{{{
Aparapi.forEach(int range, IntBlock lambda);
}}}

The Java 8 stream API defines a type called java.util.function.IntBlock. This is essentially an interface with a Single Abstract Method (these types are referred to as SAM types in the stream API code). 

IntBlock looks something like....

{{{
interface IntBlock{
   public void accept(int Id); 
}
}}}


So you can defined a kernel as  

{{{
int in[] = ..// 
int out[] = .../
Aparapi.forEach(in.length, (i)->{
   out[i] = in[i]*in[i];
 });
}}}

Instead of

{{{
int in[] = ..// 
int out[] = .../
Aparapi.forEach(in.length, new IntBlock(){
   public void accept(int i){
       out[i] = in[i]*in[i];
   }
 });
}}}

Eric created Aparapi.ForEach() which takes an int (range) and a IntBlock as a lambda and converts the bytecode of the lambda to OpenCL.  The captured args (in[], out[] and i -  in this case) are passed to the GPU and the kernel executed. 

We hit an interesting issue. The new lambdafied javac uses Java 7 method handles and invoke dynamic instruction to dispatch the lambda code.  It does this by injecting a call to a MethodHandle factory into the call site.  At runtime, this factory creates a synthetic class (to capture call-site args) and passes this as the second arg to Aparapi.forEach().

We needed to analyse this synthetically generated class in order to work out which args need to be sent to the GPU.  Of course we have a bunch of tools already in Aparapi for analyzing bytecode, but this code expects to find bytecode in class files (either in a Jar or on the disk), we had to find a way to access these classfile bytes to Aparapi.

Initially Eric modified the Java 8 runtime code which created the synthetic class to create a side table which we could access from Aparapi (this meant we were modifying Java 8 JDK code - actually the aptly named sun.misc.Unsafe class) which was fine for a short term hack.  Once we had the bytecode for the synthetic method we could extract (reflectively) the args. 

We were unhappy with this for 'production' Aparapi. As we need to have a way to do this without changing the JDK. In the end we managed to create a  [http://javahowto.blogspot.com/2006/07/javaagent-option.html javaagent] to track the loading of synthetic classes.  This seems to work just fine.

In future instead of 

{{{
java -classpath path/to/aparapi.jar:your.jar YourClass
}}}

We may need to launch using 
{{{
java -javaagent:path/to/aparapi.jar -classpath your.jar YourClass
}}}


  