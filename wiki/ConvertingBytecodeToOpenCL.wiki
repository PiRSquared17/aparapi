#summary How Aparapi converts bytecode to OpenCL

= Introduction =

One of the unique Aparapi features is it's ability to convert Java bytecode to OpenCL automatically. 

In this page we will try to describe the process used to perform this conversion. 
 
If you are unfamiliar with bytecode consider visiting this page WhatIsBytecode.

The command
{{{
javac Source.java
}}}

Will compile the java source file _Source.java_ to _Source.class_

The classfile format is well documented [http://en.wikipedia.org/wiki/Java_class_file here] and we will not go into too much detail here, however it should be known that Aparapi must parse the classfile of each {{{Kernel}}} to extract the bytecode for the {{{Kernel.run()}}} and any method reachable from {{{Kernel.run()}}}.

Lets start with a simple Kernel.

{{{
import com.amd.aparapi.Kernel;

public class Squarer extends Kernel{
   int[] in;
   int[] out;
   @Override public void run(){
      int gid = getGlobalId(0);
      out[gid] = in[gid] * in[gid]; 
   }
}
}}}

We will compile this 

{{{
javac -g -cp path/to/aparapi/aparapi.jar Squarer.java
}}}

and then we can look at the bytecode using {{{javap}}}

{{{
javap -c -classpath path/to/aparapi/aparapi.jar;. Squarer
Compiled from "Squarer.java"
public class Squarer extends com.amd.aparapi.Kernel{
int[] in;

int[] out;

public Squarer();
  Code:
   0:   aload_0
   1:   invokespecial   #1; //Method com/amd/aparapi/Kernel."<init>":()V
   4:   return

public void run();
  Code:
   0:   aload_0
   1:   iconst_0
   2:   invokevirtual   #2; //Method getGlobalId:(I)I
   5:   istore_1
   6:   aload_0
   7:   getfield        #3; //Field out:[I
   10:  iload_1
   11:  aload_0
   12:  getfield        #4; //Field in:[I
   15:  iload_1
   16:  iaload
   17:  aload_0
   18:  getfield        #4; //Field in:[I
   21:  iload_1
   22:  iaload
   23:  imul
   24:  iastore
   25:  return

}
}}}

Here we see the bytecode of the default constructor {{{Squarer()}}} and the {{{Squarer.run()}}} method we are really interested in. 

Bytecode is basically able to access three things
 * Constant pool entries
 * Variable slots
 * Stack operands

Instructions are able to pop operands from the stack, push operands to the stack, load values from variable slots (to the stack), store values (from the stack) to variable slots, store values from accessed fields (to the stack) and call methods (popping args from the stacl). 

Instructions that act upon data are only able to handle specific types (int, float, double,  and object instances - arrays are special forms of objects) and usually the first character of the instruction helps determine which type the instruction operates upon.  So imul would be a multiply instruction that operates on integers, fmul would multiply floats, dmul for doubles.  Instructions that begin with 'a' operate on object instances.   

So lets look at the first instruction.
{{{
  0:   aload_0
}}}

This instruction loads an object (a is the first character) from variable slot 0 (we'll come back to the variable slots in a moment) and pushes it on the stack. 

Variables are held in 'slots' that are reserved at compiled time.

Consider this static method. 
{{{
static int squareMe(int value){
  value += value;
  return(value);
} 
}}}

This method requires one variable slot. At any one time there is only one variable that is live, it just happens to be an argument to the method. 

The following method also contains one slot.
{{{
static int squareMe(){
  int value=4;
  value += value;
  return(value);
} 
}}}

Here we need two slots
{{{
static int squareMe(int arg){
  int value=arg*arg;
  return(value);
} 
}}}

Suprisingly the following also only requires two slots.
{{{
static int squareMe(int arg){
  {
    int temp = arg*arg;
  }
  int value=arg*arg;
  return(value);
} 
}}}

Note that in the above example the _temp_ variable loses scope before the local variable _value_ is used.  So only two slots are required.  Both _temp_ and _value_ can share a slot.  

If we have an instance method we always require one extra slot (always slot 0) for the _this_ reference. 

So 
{{{
int squareMe(int arg){
  int value=arg*arg;
  return(value);
} 
}}}
Requires three slots. 

Anyway back to our bytecode
{{{
  0:   aload_0
}}}
This loads the object instance in slot 0 (this) and pushes it on the stack. 

Next we have
{{{
  1:   iconst_0
}}}
Which pushes the int constant 0 on the stack. So the stack contains {this,0}

Next we have 
{{{
  2:   invokevirtual   #2; //Method getGlobalId:(I)I
}}}
This is the bytecode for calling a method.  Basically the instruction itself references the constant pool (we'll come back to this ;) ) and pulls the method description in constantPool[2] which happens to be the description for a method called getGlobalId() which takes an integer and returns an int. 

So the VM will pop the top value (int - const 0) as the method arg, and then will pop an object reference (this!) and will call the method {{{this.getGlobalId(0)}}} and will push the result (an int) back on the stack.

So our stack which contains {this,0} now contains the result of {{{this.getGlobalId(0)}}}, lets assume it is {0}.  We describe this invoke instruction as consuming two operands from the stack and producing one.


 