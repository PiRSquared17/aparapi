#summary How to extend Aparapi to allow multiple entrypoints for kernels

= Current state of play =


At present Aparapi allows a kernel to be called via a 'single entry point'. Essentially for each {{{Kernel}}} only the one overridden {{{Kernel.run()}}} (and run-reachable methods) method can be converted to OpenCL and executed on the GPU.

Our canonical example is the 'Squarer' Kernel which allows us to create squares for each element in an input array in an output array. 

{{{
Kernel squarer = new Kernel(){
   @Overide public void run(){
      int id = getGlobalId(0);
      out[id] = in[id] * in[id];
   }
}; 
}}}

If we wanted a vector addition Kernel we would have to create a whole new Kernel.

{{{
Kernel adder = new Kernel(){
   @Overide public void run(){
      int id = getGlobalId(0);
      out[id] = in[id] * in[id];
   }
}; 
}}}

So to square and then add a constant we would have to invoke two kernels. Or of course create single SquarerAdder kernel.

If we wanted to create a general VectorMath Kernel which might expose square, squareroot, addition, subtraction functionality we have to perform some 'unnatural acts'.  

For example we can approximate by passing a separate arg to dictate the 'function' that we wish to perform.

{{{
class VectorKernel extends Kernel{
    float[] lhsOperand;
    float[] rhsOperand;
    float[] unaryOperand;
    float[] result;
    final static int FUNC_ADD =0; 
    final static int FUNC_SUB =1;
    final static int FUNC_SQR =2;
    final static int FUNC_SQRT =3;
    // other functions
    int function;
    @Override public void run(){
        int gid = getGlobalId(0){
        if (function==FUNC_ADD){
           result[gid]=lhsOperand[gid]+rhsOperand[gid];
        }else if (function==FUNC_SUB){
           result[gid]=lhsOperand[gid]-rhsOperand[gid];
        }else if (function==FUNC_SQR){
           result[gid]=unaryOperand[gid]*unaryOperand[gid];
        }else if (function==FUNC_ADD){
           result[gid]=sqrt(unaryOperand[gid]);
        }else if ....
    } 
}  
}}}

To use this for adding two vectors and then take the sqrt of the result we would use something like....

{{{
int SIZE=1024;
Range range = Range.create(SIZE);
VectorKernel vk = new VectorKernel();
vk.lhsOperand = new float[SIZE];
vk.rhsOperand = new float[SIZE];
vk.unaryOperand = new float[SIZE];
vk.result = new float[SIZE];

// fill lhsOperand ommitted
// fill rhsOperand ommitted
vk.function = VectorKernel.FUNC_ADD;
vk.execute(range);  
System.arrayCopy(vk.result, 0, vk.unaryOperand, 0, SIZE);
vk.function = VectorKernel.FUN_SQRT;
vk.execute(range); 
}}}

This approach is fairly common and I have used it to perform various pipeline stages for calculating FFT's for example. 
 
Whilst this is functional it is not a great solution. First the API is clumsy.  We have to mutate the state of the kernel instance and then re-arrange the arrays manually to chain math operations. We could of course hide all of this behind helper methods.  One could imagine for example 

{{{
VectorKernel vk = new VectorKernel(SIZE);
vk.add(copyLhs, copyRhs);  // copies args to lhs and rhs operands
                           // sets function type
                           // and executes kernel
vk.sqrt();                 // because we have no arg
                           // copies result to unary operand
                           // sets function type
                           // execute kernel  
}}}

However there is one more objection to this approach, namely that it is unnecessarily copying buffers.  

When the bytecode for the above {{{Kernel.run()}}} method is analyzed Aparapi finds bytecode reading from lhsOperand, rhsOperand and unaryOperand arrays/buffers.  Obviously at this bytecode analysis stage we can't predict which 'function type' will be used, so  on every executions ({{{Kernel.run()}}}) Aparapi must copy all three buffers to the GPU. For binary operations this is one buffer copy wasted (the unaryOperand), for  the unary operations we copy two buffers unnecessarily (lhs and rhs Operands).  We can of course use explicit buffer management to help us reduce these costs, either my making the user do it implicitly. 

{{{
int SIZE=1024;
Range range = Range.create(SIZE);
VectorKernel vk = new VectorKernel();
vk.setExplicit(true);
vk.lhsOperand = new float[SIZE];
vk.rhsOperand = new float[SIZE];
vk.unaryOperand = new float[SIZE];
vk.result = new float[SIZE];

// fill lhsOperand ommitted
// fill rhsOperand ommitted
vk.function = VectorKernel.FUNC_ADD;
vk.put(vk.lhsOperand).put(vk.rhsOperand);
vk.execute(range);  
vk.get(vk.result);
System.arrayCopy(vk.result, 0, vk.unaryOperand, 0, SIZE);
vk.function = VectorKernel.FUN_SQRT;
vk.put(vk.unaryOperand);
vk.execute(range); 
vk.get(vk.result);
}}}

Or we can hide these behind helper methods.

= Why can't Aparapi just allow 'arbitary' methods = 

Ideally we would just expose a more natural API, one which allows us to provide specific methods for each arithmetic operation.  

Essentially 

{{{
class VectorKernel extends Kernel{
   public void add();
   public void sub();
   public void sqr();
   public void sqrt();
}
}}}

Unfortunately this is hard for us to implement using Aparapi. There are two distinct problems, both at runtime.

 # How will Aparapi know which of the available methods we want to execute when we call {{{Kernel.execute(range)}}}?
 # On first execution how does Aparapi determine which methods *might* be entrypoints and are therefore need to be converted to OpenCL?


The first problem can be solved by extending {{{Kernel.execute()}}} to accept a method name 

{{{
kernel.execute(SIZE, "add");
}}}

This is the obvious solution, but really causes maintenence issues as it trades compile time checking for a runtime error.  If a developer mistypes the name of the method, :-

{{{
kernel.execute(SIZE, "sadd"); // there is no such method 
}}}

The code will compile, but no error can be reported until runtime.

==An aside ===
Maybe the new Java 8 method reference feature method might help here. In this paper Brian Goetz talks about a double-colon syntax (Class::Method) for directly referencing a method which is presumably checked at compile time.
{{{
kernel.execute(SIZE, VectorKernel::sadd); // would fail? 
}}}

See [http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-4.html Brian Goetz's excellent Lambda documentation]

==back from Aside==

The second problem (knowing which methods need to be converted to OpenCL) can probably be solved using an Annotation. 
{{{
class VectorKernel extends Kernel{
   @EntryPoint public void add();
   @EntryPoint public void sub();
   @EntryPoint public void sqr();
   @EntryPoint public void sqrt();
   public void nonOpenCLMethod();
}
}}}

Whereby the {{{@EntryPoint}}} annotation allows the Aparapi runtime to determine which methods need to be exposed. 

=My Extension Proposal=

Here is my proposal.  Not only does it allow us to reference multiple entryoints, but it actually improves (I think) the single entrypoint API, albeit at the cost of being more verbose. 

First I propose that we should ask the developer to provide an interface for all methods that we wish to execute on the GPU (or convert to OpenCL). 

{{{
interface VectorAPI extends AparapiAPI {
   public void add(Range range);
   public void sub(Range range);
   public void sqrt(Range range);
   public void sqr(Range range);
}
}}}

Note that each API takes a {{{Range}}}, this will make more sense in a moment.

We should also provide a mechanism for mapping the proposed  implementation of the API (note the weasel words, this is not a conventional implementation of an interface!) using a new annotation @Implements(Class class).

{{{
@Implements(VectorAPI.class) class Vector extends Kernel {
   public void add(RangeId rangeId){/*implementation here */}
   public void sub(RangeId rangeId){/*implementation here */}
   public void sqrt(RangeId rangeId){/*implementation here */}
   public void sqr(RangeId rangeId){/*implementation here */}
   public void  public void nonOpenCLMethod();
}
}}}

We instantiate our Kernel by creating an instance using {{{new}}}, but then force the OpenCL generation by asking an instance for access to the API.  Some java.util.Proxy 

Using something like. 
{{{
Vector kernel = new Vector();
VectorAPI kernelApi = kernel.api();
Range range = Range.create(SIZE);
kernalApi.add(range);
}}}

So the Vector instance is a pure Java implementation.  The extracted API is the bridge to the GPU.

Of course then we can execute using an inline call through {{{api()}}}

{{{
Vector kernel = new Vector();
Range range = Range.create(SIZE);
kernel.api().add(range);
kernel.api().sqrt(range);
}}}

or even expose {{{api}}} as public final fields 

{{{
Vector kernel = new Vector();
Range range = Range.create(SIZE);
kernel.api.add(range);
kernel.api.sqrt(range);
}}}

= Extending this to allow argument passing =



---
below this line is just some implementation musings

Standby whilst I prepare a proposal based on some Proxy hacking.....

Just a collection of code at present.

{{{
public static class Squarer{
  interface API {
    public API foo(Range range, int[] in, int[] out);
    public Squarer dispatch();
  }

  public API foo(RangeId rangeId, int[] in, int[] out) {
     out[rangeId.wgid] = in[rangeId.wgid]*in[rangeId.wgid];
     return(null);
  }
}
}}}

{{{
Squarer.API squarer = create(new Squarer(), Squarer.API.class);
int[] in = new int[] {...}
int[] out = new int[in.length];
Range range = new Range(in.length);

squarer.foo(range, in, out);
      
for (int s:out){
   System.out.println(s);
}
}}}

test harness
{{{
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;


public class Ideal{

   public static class OpenCLInvocationHandler<T> implements InvocationHandler {
       Object instance;
       OpenCLInvocationHandler(Object _instance){
          instance = _instance;
       }
      @Override public Object invoke(Object interfaceThis, Method interfaceMethod, Object[] interfaceArgs) throws Throwable {
         Class clazz = instance.getClass();
         
         Class[] argTypes =  interfaceMethod.getParameterTypes();
         argTypes[0]=RangeId.class;
         Method method = clazz.getDeclaredMethod(interfaceMethod.getName(), argTypes);
         
         
         if (method == null){
            System.out.println("can't find method");
         }else{
            RangeId rangeId = new RangeId((Range)interfaceArgs[0]);
            interfaceArgs[0]=rangeId;
            for (rangeId.wgid = 0; rangeId.wgid <rangeId.r.width; rangeId.wgid++){
                method.invoke(instance, interfaceArgs);
            }
         }
         
         return null;
      }
   }

   static class Range{
      int width;
      Range(int _width) {
         width = _width;
      }
   }

   static class Range2D extends Range{
      int height;

      Range2D(int _width, int _height) {
         super(_width);
         height = _height;
      }
   }

   static class Range1DId<T extends Range>{
      Range1DId(T _r){
         r = _r;
      }
      T r;

      int wgid, wlid, wgsize, wlsize, wgroup;
   }
   
   static class RangeId  extends Range1DId<Range>{
      RangeId(Range r){
         super(r);
      }
   }

   static class Range2DId extends Range1DId<Range2D>{
      Range2DId(Range2D r){
         super(r);
      }

      int hgid, hlid, hgsize, hlsize, hgroup;
   }

  
   
  

   static <T> T create(Object _instance, Class<T> _interface) {
      OpenCLInvocationHandler<T> invocationHandler = new OpenCLInvocationHandler<T>(_instance);
      T instance = (T) Proxy.newProxyInstance(Ideal.class.getClassLoader(), new Class[] {
            _interface,
          
      }, invocationHandler);
      return (instance);

   }
   
   
   
   public static class Squarer{
      interface API {
         public API foo(Range range, int[] in, int[] out);
         public Squarer dispatch();

      }

      public API foo(RangeId rangeId, int[] in, int[] out) {
         out[rangeId.wgid] = in[rangeId.wgid]*in[rangeId.wgid];
         return(null);
      }
   }

   /**
    * @param args
    */
   public static void main(String[] args) {
      
      Squarer.API squarer = create(new Squarer(), Squarer.API.class);
      int[] in = new int[] {
            1,
            2,
            3,
            4,
            5,
            6
      };
      int[] out = new int[in.length];
      Range range = new Range(in.length);

      squarer.foo(range, in, out);
      
      for (int s:out){
         System.out.println(s);
      }

   }

}
}}}